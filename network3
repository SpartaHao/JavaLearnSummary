11. OSI七层协议有了解么？Ip协议是哪层协议？

OSI的七层协议、TCP/IP的四层协议、谢希仁老师的网络课本提到的五层协议的对比
注：
(1)OSI的七层协议只是理论上的协议，实际上没有用到。
(2)TCP/IP的四层协议在真正在实际中用到的体系结构。
(3)谢老课本中提到的五层协议只是为了更好的讲解概念而采用的折中方法。

来自 <https://blog.csdn.net/insistgogo/article/details/10296167> 

分层是为了解耦。https可以归到表示层（是否加密）和会话层里（是否有token和证书验证）

Ø 一个设备工作在哪一层，关键看它工作时利用哪一层的数据头部信息。网桥工作时，是以MAC头部来决定转发端口的，因此显然它是数据链路层的设备。
具体说:
物理层：网卡，网线，集线器，中继器，调制解调器
数据链路层：网桥，交换机
网络层：路由器
网关工作在第四层传输层及其以上

集线器是物理层设备,采用广播的形式来传输信息。交换机就是用来进行报文交换的机器。多为链路层设备(二层交换机)，能够进行地址学习，采用存储转发的形式来交换报文。路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。选择通畅快捷的近路，能大大提高通信速度，减轻网络系统通信负荷，节约网络系统资源，提高网络系统畅通率。 交换机是利用物理地址或者说MAC地址来确定转发数据的目的地址。而路由器则是利用IP地址来确定数据转发的地址。

Ø IP协议工作在网络层；DNS工作在应用层；ARP工作在数据链路层;TCP、UDP工作在传输层；SSL、TLS工作在会话层

Ø 简短表示：
物理层：负责在网络上透明地传送比特流
数据单元:比特流
注意：物理层关注的重点在于，如何才能在各种介质上传送比特流，而并不指具体的传输媒体。

数据链路层：物理寻址，同时将原始比特流封装成帧，使有差错的物理线路变为无差错的数据链路；
数据单元：帧
注意：
1、数据链路层侧重点在于，如何在不可靠的物理线路上进行数据的可靠传递。
2、在OSI模型中，数据链路层向上提供可靠传输的服务，即具有重传和确认机制。但是在实际的应用中，TCP/IP的数据链路层不要求提供可靠传输。可靠传输有运输层控制。

网络层：主要解决网络路由和通信问题，根据路由算法，为报文或数据分组选择最佳路径；
数据单元：IP数据报或数据报或分组。
说明：网络层向上只提供简单灵活的、无连接的、尽最大可能交付的数据报服务，使得路由器做的就比较简单。
1、网络在发送分组时，不需要先建立连接。
2、每一个分组独立发送，与前后分组无关。
3、在传送过程中，所传送的分组可能出错、丢失、重复和失序、而且也不保证分组交付的时限。
注意：网络层不保证通信时可靠的，但可以由运输层负责（差错处理、流量控制等）。


传输层：为两个主机中进程之间的通信提供服务。该层是通信子网和资源子网的接口和桥梁，起到承上启下的作用。传输层的作用是向高层屏蔽下层数据通信的细节，即向用户透明地传送报文；负责数据分割（传送端）和数据组合（接收端），并提供可靠的“面向连接”和不太可靠的“面向无连接”的数据传输服务、差错控制和流量控制；
说明：
1、待传输的数据在上三层是整体的，到了运输层是开始分割，分割后的数据称为段。
2、三次握手、面向连接和非面向连接的服务、流量控制都发生在这一层。

会话层：为网络中两个结点（通信双方）制定通信方式，并建立、维护、控制、注销会话等。

表示层：负责数据的编码和转化，确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取（相互识别）。 主要功能是“处理用户信息的表示问题，如编码、数据格式转换、压缩及解压缩和加密解密”等，根据不同的应用目的将数据变成不同的格式（表现出来就是各种文件扩展名）

应用层：应用层是用户与网络，以及应用程序与网络间的直接接口，使得用户能够与网络进行交互式联系，其功能是直接向用户提供服务，完成用户希望在网络上完成的各种工作。如HTTP,FTP,SMTP,RPC,DNS等。 注意：应用层并不是指运行在网络上的某个特别应用程序，而是指为用户的应用进程提供的服务

Ø 物理层
在OSI参考模型中，物理层（Physical Layer）是参考模型的最低层，也是OSI模型的第一层。
物理层的主要功能是：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。
物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。

数据链路层
数据链路层（Data Link Layer）是OSI模型的第二层，负责建立和管理节点间的链路。该层的主要功能是：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。
在计算机网络中由于各种干扰的存在，物理链路是不可靠的。因此，这一层的主要功能是在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。
该层通常又被分为介质访问控制（MAC）和逻辑链路控制（LLC）两个子层：
MAC子层的主要任务是解决共享型网络中多用户对信道竞争的问题，完成网络介质的访问控制；
LLC子层的主要任务是建立和维护网络连接，执行差错校验、流量控制和链路控制。

数据链路层的具体工作是接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层；并且，还负责处理接收端发回的确认帧的信息，以便提供可靠的数据传输。

网络层
网络层（Network Layer）是OSI模型的第三层，它是OSI参考模型中最复杂的一层，也是通信子网的最高一层。它在下两层的基础上向资源子网提供服务。其主要任务是：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。该层控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。
一般地，数据链路层是解决同一网络内节点之间的通信，而网络层主要解决不同子网间的通信。例如在广域网之间通信时，必然会遇到路由（即两节点间可能有多条路径）选择问题。 

在实现网络层功能时，需要解决的主要问题如下：
 寻址：数据链路层中使用的物理地址（如MAC地址）仅解决网络内部的寻址问题。在不同子网之间通信时，为了识别和找到网络中的设备，每一子网中的设备都会被分配一个唯一的地址。由于各子网使用的物理技术可能不同，因此这个地址应当是逻辑地址（如IP地址）。
 交换：规定不同的信息交换方式。常见的交换技术有：线路交换技术和存储转发技术，后者又包括报文交换技术和分组交换技术。
 路由算法：当源节点和目的节点之间存在多条路径时，本层可以根据路由算法，通过网络为数据分组选择最佳路径，并将信息从最合适的路径由发送端传送到接收端。
 连接服务：与数据链路层流量控制不同的是，前者控制的是网络相邻节点间的流量，后者控制的是从源节点到目的节点间的流量。其目的在于防止阻塞，并进行差错检测。

传输层
OSI下3层的主要任务是数据通信，上3层的任务是数据处理。而传输层（Transport Layer）是OSI模型的第4层。因此该层是通信子网和资源子网的接口和桥梁，起到承上启下的作用。
该层的主要任务是：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。传输层的作用是向高层屏蔽下层数据通信的细节，即向用户透明地传送报文。该层常见的协议：TCP/IP中的TCP协议、Novell网络中的SPX协议和微软的NetBIOS/NetBEUI协议。
传输层提供会话层和网络层之间的传输服务，这种服务从会话层获得数据，并在必要时，对数据进行分割。然后，传输层将数据传递到网络层，并确保数据能正确无误地传送到网络层。因此，传输层负责提供两节点之间数据的可靠传送，当两节点的联系确定之后，传输层则负责监督工作。综上，传输层的主要功能如下：
传输连接管理：提供建立、维护和拆除传输连接的功能。传输层在网络层的基础上为高层提供“面向连接”和“面向无接连”的两种服务。
处理传输差错：提供可靠的“面向连接”和不太可靠的“面向无连接”的数据传输服务、差错控制和流量控制。在提供“面向连接”服务时，通过这一层传输的数据将由目标设备确认，如果在指定的时间内未收到确认信息，数据将被重发。

会话层
会话层（Session Layer）是OSI模型的第5层，是用户应用程序和网络之间的接口，主要任务是：向两个实体的表示层提供建立和使用连接的方法。将不同实体之间的表示层的连接称为会话。因此会话层的任务就是组织和协调两个会话进程之间的通信，并对数据交换进行管理。
用户可以按照半双工、单工和全双工的方式建立会话。当建立会话时，用户必须提供他们想要连接的远程地址。而这些地址与MAC（介质访问控制子层）地址或网络层的逻辑地址不同，它们是为用户专门设计的，更便于用户记忆。域名（DN）就是一种网络上使用的远程地址例如：www.3721.com就是一个域名。会话层的具体功能如下：
会话管理：允许用户在两个实体设备之间建立、维持和终止会话，并支持它们之间的数据交换。例如提供单方向会话或双向同时会话，并管理会话中的发送顺序，以及会话所占用时间的长短。
 会话流量控制：提供会话流量控制和交叉会话功能。
寻址：使用远程地址建立会话连接。l
出错控制：从逻辑上讲会话层主要负责数据交换的建立、保持和终止，但实际的工作却是接收来自传输层的数据，并负责纠正错误。会话控制和远程过程调用均属于这一层的功能。但应注意，此层检查的错误不是通信介质的错误，而是磁盘空间、打印机缺纸等类型的高级错误。

表示层
表示层（Presentation Layer）是OSI模型的第六层，它对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传送给会话层。其主要功能是“处理用户信息的表示问题，如编码、数据格式转换和加密解密”等。表示层的具体功能如下：
数据格式处理：协商和建立数据交换的格式，解决各应用程序之间在数据格式表示上的差异。
数据的编码：处理字符集和数字的转换。例如由于用户程序中的数据类型（整型或实型、有符号或无符号等）、用户标识等都可以有不同的表示方式，因此，在设备之间需要具有在不同字符集或格式之间转换的功能。
压缩和解压缩：为了减少数据的传输量，这一层还负责数据的压缩与恢复。
数据的加密和解密：可以提高网络的安全性。

应用层
应用层（Application Layer）是OSI参考模型的最高层，它是计算机用户，以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，完成用户希望在网络上完成的各种工作。它在其他6层工作的基础上，负责完成网络中应用程序与网络操作系统之间的联系，建立与结束使用者之间的联系，并完成网络用户提出的各种网络服务及应用所需的监督、管理和服务等各种协议。此外，该层还负责协调各个应用程序间的工作。
应用层为用户提供的服务和协议有：文件服务、目录服务、文件传输服务（FTP）、远程登录服务（Telnet）、电子邮件服务（E-mail）、打印服务、安全服务、网络管理服务、数据库服务等。上述的各种网络服务由该层的不同应用协议和程序完成，不同的网络操作系统之间在功能、界面、实现技术、对硬件的支持、安全可靠性以及具有的各种应用程序接口等各个方面的差异是很大的。应用层的主要功能如下：
用户接口：应用层是用户与网络，以及应用程序与网络间的直接接口，使得用户能够与网络进行交互式联系。
实现各种服务：该层具有的各种应用程序可以完成和实现用户请求的各种服务。

OSI 7层模型的小结
由于OSI是一个理想的模型，因此一般网络系统只涉及其中的几层，很少有系统能够具有所有的7层，并完全遵循它的规定。
在7层模型中，每一层都提供一个特殊的网络功能。从网络功能的角度观察：下面4层（物理层、数据链路层、网络层和传输层）主要提供数据传输和交换功能，即以节点到节点之间的通信为主；第4层作为上下两部分的桥梁，是整个网络体系结构中最关键的部分；而上3层（会话层、表示层和应用层）则以提供用户与应用程序之间的信息和数据处理功能为主。简言之，下4层主要完成通信子网的功能，上3层主要完成资源子网的功能。
https://blog.csdn.net/yaopeng_2005/article/details/7064869

Ø TCP/IP分层模型
        ┌────------────┐┌─┬─┬─-┬─┬─-┬─┬─-┬─┬─-┬─┬─-┐
　　│　　　　　　　　││Ｄ│Ｆ│Ｗ│Ｆ│Ｈ│Ｇ│Ｔ│Ｉ│Ｓ│Ｕ│　│
　　│　　　　　　　　││Ｎ│Ｉ│Ｈ│Ｔ│Ｔ│Ｏ│Ｅ│Ｒ│Ｍ│Ｓ│其│
　　│第四层，应用层　││Ｓ│Ｎ│Ｏ│Ｐ│Ｔ│Ｐ│Ｌ│Ｃ│Ｔ│Ｅ│　│
　　│　　　　　　　　││　│Ｇ│Ｉ│　│Ｐ│Ｈ│Ｎ│　│Ｐ│Ｎ│　│
　　│　　　　　　　　││　│Ｅ│Ｓ│　│　│Ｅ│Ｅ│　│　│Ｅ│它│
　　│　　　　　　　　││　│Ｒ│　│　│　│Ｒ│Ｔ│　│　│Ｔ│　│
　　└───────------─┘└─┴─┴─-┴─┴─-┴─┴─-┴─┴─-┴─┴-─┘
　　┌───────-----─┐┌─────────-------┬──--------─────────┐
　　│第三层，传输层　││　　　ＴＣＰ　　　│　　　　ＵＤＰ　　　　│
　　└───────-----─┘└────────-------─┴──────────--------─┘
　　┌───────-----─┐┌───----──┬───---─┬────────-------──┐
　　│　　　　　　　　││　　　　　│ＩＣＭＰ│　　　　　　　　　　│
　　│第二层，网间层　││　　　　　└──---──┘　　　　　　　　　　│
　　│　　　　　　　　││　　　　　　　ＩＰ　　　　　　　　　　　 │
　　└────────-----┘└────────────────────-------------─-┘
　　┌────────-----┐┌─────────-------┬──────--------─────┐
　　│第一层，网络接口││ＡＲＰ／ＲＡＲＰ　│　　　　其它　　　　　│
　　└────────------┘└─────────------┴─────--------──────┘
　　　　　　 TCP/IP四层参考模型

　　TCP/IP协议被组织成四个概念层，其中有三层对应于ISO参考模型中的相应层。ICP/IP协议族并不包含物理层和数据链路层，因此它不能独立完成整个计算机网络系统的功能，必须与许多其他的协议协同工作。
　　TCP/IP分层模型的四个协议层分别完成以下的功能：
　　第一层:网络接口层
　　包括用于协作IP数据在已有网络介质上传输的协议。实际上TCP/IP标准并不定义与ISO数据链路层和物理层相对应的功能。相反，它定义像地址解析协议(Address Resolution Protocol,ARP)这样的协议，提供TCP/IP协议的数据结构和实际物理硬件之间的接口。
　　第二层:网间层
　　对应于OSI七层参考模型的网络层。本层包含IP协议、RIP协议(Routing Information Protocol，路由信息协议)，负责数据的包装、寻址和路由。同时还包含网间控制报文协议(Internet Control Message Protocol,ICMP)用来提供网络诊断信息。
　　第三层:传输层
　　对应于OSI七层参考模型的传输层，它提供两种端到端的通信服务。其中TCP协议(Transmission Control Protocol)提供可靠的数据流运输服务，UDP协议(Use Datagram Protocol)提供不可靠的用户数据报服务。
　　第四层:应用层
　　对应于OSI七层参考模型的应用层和表达层。因特网的应用层协议包括Finger、Whois、FTP(文件传输协议)、Gopher、HTTP(超文本传输协议)、Telent(远程终端协议)、SMTP(简单邮件传送协议)、IRC(因特网中继会话)、NNTP（网络新闻传输协议）等


12. ping命令作用？使用的什么协议？
<1> 作用:它测试两个主机之间的连通性。
<2> 使用网络层协议ICMP协议。ICMP是网络层的自我检测，用来检测信息是否到达目的地。若没到达，则提供原因；
注意：ping命令，它没有通过运输层协议(TCP、UDP)而直接使用网络层协议。

13. https和http的区别？https的流程可以描述一下么？如果没有证书可以么？加密和签名的区别（了解）？
Ø https协议需要CA申请证书；
http协议运行在TCP协议之上,传输的内容都是明文传送,安全性较差,而https则是运行在SSL/TLS层之上, 而SSL/TLS层是运行在TCP层之上,https传输的内容都是经过加密的,安全性较高；
http与https使用不同的连接方式.其中http默认用的是80端口,而https默认用的是443端口(uzi打kid的那个443)；

Ø HTTP 协议中没有加密机制,但可以通过和 SSL(Secure Socket Layer, 安全套接层 )或 TLS(Transport Layer Security, 安全层传输协议)的组合使用,加密 HTTP 的通信内容。属于通信加密，即在整个通信线路中加密。
HTTP + 加密 + 认证 + 完整性保护 = HTTPS（HTTP Secure ）




1）客户端发起一个http请求，连接到服务器的443端口，同时将自己支持的一套加密规则发送给网站----服务器获得浏览器公钥
	
2）服务端从中选出一组加密算法与HASH算法，并把自己的信息以数字证书的形式返回给客户端（证书包含证书颁发机构，证书有效期，服务端地址，公钥，证书所有者，签名使用的算法等信息）。证书中有一个公钥来加密信息，私钥由服务器持有。----浏览器获得服务器公钥
	
3）验证证书的合法性
客户端收到服务器的响应后会先验证证书的合法性（证书中包含的地址与正在访问的地址是否一致，证书是否过期）。
	
4）生成随机密码（RSA签名）
如果验证通过，或用户接受了不受信任的证书，浏览器就会生成一个随机的对称密钥（session key）并用公钥加密。然后使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给服务端。让服务端用私钥解密，解密后就用这个对称密钥进行传输了，并且能够说明服务端确实是私钥的持有者。
	
5）生成对称加密算法
服务端使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。然后使用密码加密一段握手消息，发送给浏览器。之后客户端与服务端可以用这个对称加密算法来加密和解密通信内容了。
	
Ø 没有证书的话没有办法验证服务端的合法性。如：劫持者拦截客户端的请求后，将自己的公钥发给客户端，伪造服务端与客户端进行通信。证书就是用来确保服务端是合法受信的。
当客户端 https 请求服务端时候，服务端会返回一个数字证书给客户浏览器，客户浏览器使用早已内置在浏览器中的 CA 公钥（其实是内置的根证书中有公钥）对数字证书中的数字签名进行解密操作得到数字指纹，然后浏览器再对数字证书中的公钥进行数字摘要算法转为数字指纹，浏览器将解密得到的数字指纹和刚新生成的数字指纹进行比对，如果一致就表示证书合规，所访问的网站是合法的。
	
证书中包含如下：
服务器的公钥
数字证书认证机构的数字签名：服务端公钥通过数字摘要算法先转为数字指纹，在使用 CA 的密钥对数字指纹进行加密得到数字签名。

Ø 签名就是在信息的后面再加上一段内容，可以证明信息没有被修改过。拿A给B发送经过签名加密信息来说：
1、A对信息签名的作用是确认这个信息是A发出的，不是别人发出的；
2、加密是对内容进行机密性保护，主要是保证信息内容不会被其他人获取，只有B可以获取。
也就是保证整个过程的端到端的唯一确定性，这个信息是A发出的（不是别人），且是发给B的，只有B才被获得具体内容（别人就算截获信息也不能获得具体内容）

A向B发送信息的整个签名和加密的过程如下（非对称加密）：
1、A先用自己的私钥（PRI_A）对信息（一般是信息的摘要）进行签名。
2、A接着使用B的公钥（PUB_B）对信息内容和签名信息进行加密。

这样当B接收到A的信息后，获取信息内容的步骤如下： 
1、用自己的私钥（PRI_B）解密A用B的公钥（PUB_B）加密的内容；
2、得到解密后的明文后用A的公钥（PUB_A）解签A用A自己的私钥（PRI_A）的签名。从而整个过程就保证了开始说的端到端的唯一确认。A的签名只有A的公钥才能解签，这样B就能确认这个信息是A发来的；A的加密只有B的私钥才能解密，这样A就能确认这份信息只能被B读取。
https://www.zhihu.com/question/27669212/answer/38037256


14. Cookie和session和token的区别是什么？
Ø cookie 是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。
cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。

Ø 当用户第一次通过浏览器使用用户名和密码访问服务器时，服务器会验证用户数据，验证成功后在服务器端写入session数据，向客户端浏览器返回sessionid，浏览器将sessionid保存在cookie中，当用户再次访问服务器时，会携带sessionid，服务器会拿着sessionid从数据库获取session数据，然后进行用户信息查询，查询到，就会将查询到的用户信息返回，从而实现状态保持。这种用户信息存储方式相对cookie来说更安全。

弊端：
1、服务器压力增大
通常session是存储在内存中的，每个用户通过认证之后都会将session数据保存在服务器的内存中，而当用户量增大时，服务器的压力增大。

2、CSRF跨站伪造请求攻击
session是基于cookie进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。

3、扩展性不强
如果将来搭建了多个服务器，虽然每个服务器都执行的是同样的业务逻辑，但是session数据是保存在内存中的（不是共享的），用户第一次访问的是服务器1，当用户再次请求时可能访问的是另外一台服务器2，服务器2获取不到session信息，就判定用户没有登陆过。
https://blog.csdn.net/mydistance/article/details/84545768

Ø Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。
使用Token的目的：Token的目的是为了减轻服务器的压力，节省服务器内存，提高服务器的扩展能力；数字签名仿伪造攻击。

使用session时，鉴权状态在服务器中处理，而token则在客户端管理。

有了token，访问特定页面，用户就不需要每次都输入账号和密码登录

来自 <https://www.cnblogs.com/jinbuqi/p/10347800.html> 

Ø Token的实现原理：JSON Web Token（JWT）方式

1） 将荷载payload，以及Header信息进行Base64加密，形成密文payload密文，header密文。
2） 将形成的密文用句号链接起来，用服务端秘钥进行HS256加密，生成签名.
3） 将前面的两个密文后面用句号链接签名形成最终的token返回给服务端

说明：
（1）用户请求时携带此token（分为三部分，header密文，payload密文，签名）到服务端，服务端解析第一部分（header密文），用Base64解密，可以知道用了什么算法进行签名，此处解析发现是HS256。
（2）服务端使用原来的秘钥与密文(header密文+"."+payload密文)同样进行HS256运算，然后用生成的签名与token携带的签名进行对比，若一致说明token合法，不一致说明原文被修改。
（3）判断是否过期，客户端通过用Base64解密第二部分（payload密文），可以知道荷载中授权时间，以及有效期。通过这个与当前时间对比发现token是否过期。
https://blog.csdn.net/AwayFuture/article/details/102753627

使用Token验证的优势：
    无状态、可扩展
         在客户端存储的Tokens是无状态的，并且能够被扩展。基于这种无状态和不存储Session信息，负载负载均衡器能够将用户信息从一个服务传到其他服务器上。
     安全性
         请求中发送token而不再是发送cookie能够防止CSRF(跨站请求伪造)。即使在客户端使用cookie存储token，cookie也仅仅是一个存储机制而不是用于认证。不将信息存储在Session中，更加安全。
         token是有时效的，一段时间之后用户需要重新验证。我们也不一定需要等到token自动失效，token有撤回的操作，通过token revocataion可以使一个特定的token或是一组有相同认证的token无效。
https://blog.csdn.net/weixin_43549578/article/details/90576846


个人理解：token主要靠签名来检查是否登录过，base64加解密很好得到，但是因为没有HS256加密用的秘钥，所以没办法伪造，因此没办法得到正确的签名。反过来说，如果签名验证通过，说明曾经登陆过，签名是服务端返回的。
使用token也是有安全问题的，比方说token被窃取了，劫持者使用窃取的token和服务端进行通信。在网络层面上token明文传输的话会非常的危险，所以建议一定要使用HTTPS，并且把token放在post body里。可以提供一个让用户可以主动expire一个过去的token类似的机制，在被盗的时候能远程止损。

Ø cookie与session的区别
1、Session保存在服务器端，客户端不知道其中的信息，Cookie保存在客户端，服务器能够知道其中的信息；
2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗；考虑到安全应当使用session。
3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE。
4、session是基于cookie实现的（透传sessionId）。当客户端存储的cookie失效后，服务端的session不会立即销毁，会有一个延时，服务端会定期清理无效session，不会造成无效数据占用存储空间的问题。
5、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。/6、所以个人建议：将登陆信息等重要信息存放为SESSION；其他信息如果需要保留，可以放在COOKIE中
cookie和session的共同之处在于：cookie和session都是用来跟踪浏览器用户身份的会话方式，因为HTTP协议是无状态的，这种无状态意味着程序需要验证每一次请求，从而辨别客户端的身份。
https://www.cnblogs.com/ella-li/p/12008069.html

Ø token与session的区别：
token和session其实都是为了身份验证，session一般翻译为会话，而token更多的时候是翻译为令牌；
session服务器会保存一份，可能保存到缓存，文件，数据库；同样，session和token都是有过期时间一说，都需要去管理过期时间；
其实token与session的问题是一种时间与空间的博弈问题，session是空间换时间，而token是时间换空间。两者的选择要看具体情况而定。

• 基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。而session需要在服务端保存用户数据：
虽然确实都是“客户端记录，每次访问携带”，但 token 很容易设计为自包含的，也就是说，后端不需要记录什么东西，每次一个无状态请求，每次解密验证，每次当场得出合法 /非法的结论。这一切判断依据，除了固化在 CS 两端的一些逻辑之外，整个信息是自包含的。这才是真正的无状态。 
而 sessionid ，一般都是一段随机字符串，需要到后端去检索 id 的有效性。万一服务器重启导致内存里的 session 没了呢？万一 redis 服务器挂了呢？

• 作为身份认证 token安全性比session好，因为每个请求都有签名还能防止监听以及重放攻击，而session就必须靠链路层来保障通讯安全了。Token是通过加密算法（如：HMAC-SHA256算法）来实现session对象验证的，这样使得攻击者无法伪造token来达到攻击或者其他对服务器不利的行为；

15. 什么是分块传输？
我们都知道http协议是由TCP协议封装而来的应用层协议，我们和服务器之间的每次http交互都要进行三次握手和四次挥手。那么，服务器端怎么判断客户端传来的数据已经发送完了，然后断开这次tcp连接呢？我们客户端在发送给服务器端报文中有一个Connection字段，一般这个值为close。也就是说这次数据传输完成了，服务器就会断开这次tcp连接。但是，当我们要传送的数据量比较大时，一次传输不能传输完成时，该如何办呢？这就要用到数据的分块传输了。
当使用分块传输时，请求头中的 Connection字段的值为：keep-alive ，最后一个数据包的Connection字段值为：close。
当服务器端收到Connection值为keep-alive的数据包时，会先将它存储在一个缓冲区中，当收到Connection值为close的数据包时，即表明这次数据传输完成！
通常，Content-Length消息头字段表示数据的长度。数据的长度很重要，因为服务器端需要知道哪里是应答消息的结束，以及后续应答消息的开始。然而，使用分块传输编码，数据分解成一系列数据块，并以一个或多个块发送，这样可以发送数据而不需要预先知道发送内容的总大小。通常数据块的大小是一致的，但也不总是这种情况。于是我们分块进行传输数据的每一次请求的Content-Length是我们这次请求的大小，当服务器端收到 Connection值为close的请求消息后，就会把之前的Content-Length加起来，即是我们请求的数据的总大小了。

数据的分段编码(transfer-encoding)
数据的分段编码就是将完整的请求数据，分段进行编码传输。在请求头中加入这么一个字段：  Transfer-Encoding: chunked ，即表示这个报文采用了分段编码，分段编码只适用于POST提交方式。分块传输编码（Chunked transfer encoding）是一种数据传输机制，允许服务端在不预先给出报文长度的情况下，分块将输出发送给客户端，配合分块传输使用。
这时，POST请求报文中的数据部分需要改为用一系列分段来传输。每个分段包含十六进制的长度值和数据，空格也算一个长度值，长度值独占一行，最后需要用0独占一行表示编码结束。并在0后空两行表示数据包结束，不然点击提交按钮后会看到一直处于waiting状态。
https://www.cnblogs.com/csnd/p/11807694.html
