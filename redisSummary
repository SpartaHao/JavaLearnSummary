1. 什么是Redis？简述它的优缺点？
	Ø Redis（Remote Dictionary Server远程字典服务）本质上是一个是一个开源（BSD许可）的、Key-Value类型、高性能非关系型（NoSQL）内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB，因此redis被广泛应用于缓存方向。 Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外一个字符串类型的值能存储最大容量是512M，不像 memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能，比方说用他的List来做FIFO双向链表，实现一个轻量级的高性 能消息队列服务，用他的Set可以做高性能的tag系统等等。另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一个功能加强版的memcached来用，还有用来实现分布式锁等。 
	
	Ø 优点
	Ø 读写性能优异， Redis能读的速度是110000次/s，写的速度是81000次/s。
	• 支持数据持久化，支持AOF和RDB两种持久化方式。
	• 支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。
	• 数据结构丰富，除了支持string类型的value外还支持hash、set、zset、list等数据结构。
	• 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。
	
	Ø 缺点
	• 数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。
	• Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。
	• 主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。
	• Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费
	
2. 为什么要用 Redis（缓存）？
Ø 高性能：从数据库读取数据是读的硬盘，比较慢，而缓存是直接操作内存，所以速度相当快，可以提高接口响应速度。我们在碰到需要执行耗时特别久，且结果不频繁变动的 SQL，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够迅速响应。
Ø 高并发：在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用 Redis 做一个缓冲操作，让请求先访问到 Redis，而不是直接访问数据库，直接操作缓存能够承受的请求是远远大于直接访问数据库的

3. Redis相比memcached有哪些优势？
	• memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型
	• redis的速度比memcached快很多
	• redis可以持久化其数据
	• 一个字符串类型的值能存储最大容量是512M，不像 memcached只能保存1MB的数据

4. 为什么要用 Redis 而不用 map/guava 做缓存?
Ø 缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。
Ø 使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。

5. 为什么Redis需要把所有数据放到内存中？
Ø Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O 速度会严重影响性能。在内存越来越便宜的今天，redis将会越来越受欢迎。redis的maxmemory参数用于控制redis可使用的最大内存容量。如果超过maxmemory的值，就会动用淘汰策略来清理数据。maxmemory-policy设置淘汰策略。

6. redis这么快，为何是单线程的？
Ø Redis确实是单进程单线程的模型，因为Redis完全是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章的采用单线程的方案了，毕竟采用多线程会有很多麻烦。

7. Redis是单线程的，为什么还能这么快？
Ø 纯内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)；
Ø 采用单线程，避免了频繁的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
Ø 采用了非阻塞 I/O 多路复用机制；

8. Redis支持的Java客户端都有哪些？官方推荐用哪个？
	Ø Redisson、Jedis、lettuce等等，官方推荐使用Redisson。

9. Redis的过期策略怎么实现的？
Ø     redis设置过期时间：
    expire key time(以秒为单位)--这是最常用的方式，除了字符串自己独有设置过期时间的方法外，其他方法都需要依靠expire方法来设置时间，如果没有设置时间，那缓存就是永不过期
    setex(String key, int seconds, String value)--字符串独有的方式

Ø     三种过期策略：
    a.定时删除
        含义：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除
        优点：保证内存被尽快释放
        缺点：若过期key很多，删除这些key会占用很多的CPU时间，在单线程CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key定时器的创建耗时，若为每一个设置过期时间的key创建一个定时器（将会有大量的定时器产生），性能影响严重

    b.懒汉式删除
        含义：key过期的时候不删除，每次通过key获取值的时候去检查是否过期，若过期，则删除，返回null（用的时候再检查删除）。
        优点：删除操作只发生在通过key取值的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步（如果此时还不删除的话，我们就会获取到了已经过期的key了）
        缺点：若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）

    c.定期删除
        含义：每隔一段时间执行一次删除过期key操作
        优点：通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用
        缺点：在内存友好方面，不如"定时删除"（会造成一定的内存占用，但是没有懒汉式那么占用内存）
 在CPU时间友好方面，不如"懒汉式删除"（会定期的去进行比较和删除操作，cpu方面不如懒汉式，但是比定时好）
       
Ø Redis 采用的是定期删除+惰性删除策略。然后定期加惰性还不生效的话，在采用内存淘汰机制。

 懒汉式删除流程：在进行get或setnx等操作时，先检查key是否过期；
                                     若过期，删除key，然后执行相应操作；
                                     若没过期，直接执行相应操作；
定期删除流程：简单而言，对指定个数个库的每一个库随机删除小于等于指定个数个过期key
