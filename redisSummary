1. 什么是Redis？简述它的优缺点？
	Ø Redis（Remote Dictionary Server远程字典服务）本质上是一个是一个开源（BSD许可）的、Key-Value类型、高性能非关系型（NoSQL）内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB，因此redis被广泛应用于缓存方向。 Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外一个字符串类型的值能存储最大容量是512M，不像 memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能，比方说用他的List来做FIFO双向链表，实现一个轻量级的高性 能消息队列服务，用他的Set可以做高性能的tag系统等等。另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一个功能加强版的memcached来用，还有用来实现分布式锁等。 
	
	Ø 优点
	Ø 读写性能优异， Redis能读的速度是110000次/s，写的速度是81000次/s。
	• 支持数据持久化，支持AOF和RDB两种持久化方式。
	• 支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。
	• 数据结构丰富，除了支持string类型的value外还支持hash、set、zset、list等数据结构。
	• 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。
	
	Ø 缺点
	• 数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。
	• Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。
	• 主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。
	• Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费
	
2. 为什么要用 Redis（缓存）？
Ø 高性能：从数据库读取数据是读的硬盘，比较慢，而缓存是直接操作内存，所以速度相当快，可以提高接口响应速度。我们在碰到需要执行耗时特别久，且结果不频繁变动的 SQL，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够迅速响应。
Ø 高并发：在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用 Redis 做一个缓冲操作，让请求先访问到 Redis，而不是直接访问数据库，直接操作缓存能够承受的请求是远远大于直接访问数据库的

3. Redis相比memcached有哪些优势？
	• memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型
	• redis的速度比memcached快很多
	• redis可以持久化其数据
	• 一个字符串类型的值能存储最大容量是512M，不像 memcached只能保存1MB的数据

4. 为什么要用 Redis 而不用 map/guava 做缓存?
Ø 缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。
Ø 使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。

5. 为什么Redis需要把所有数据放到内存中？
Ø Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O 速度会严重影响性能。在内存越来越便宜的今天，redis将会越来越受欢迎。redis的maxmemory参数用于控制redis可使用的最大内存容量。如果超过maxmemory的值，就会动用淘汰策略来清理数据。maxmemory-policy设置淘汰策略。

6. redis这么快，为何是单线程的？
Ø Redis确实是单进程单线程的模型，因为Redis完全是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章的采用单线程的方案了，毕竟采用多线程会有很多麻烦。

7. Redis是单线程的，为什么还能这么快？
Ø 纯内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)；
Ø 采用单线程，避免了频繁的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
Ø 采用了非阻塞 I/O 多路复用机制；

8. Redis支持的Java客户端都有哪些？官方推荐用哪个？
	Ø Redisson、Jedis、lettuce等等，官方推荐使用Redisson。

9. Redis和Redisson有什么关系？Jedis与Redisson对比有什么优缺点？
Ø Redis 其实并没有对 Java 提供原生支持。作为 Java 开发人员，我们若想在程序中集成 Redis，必须使用 Redis 的第三方库。而 Redisson 就是用于在 Java 程序中操作 Redis 的库，它使得我们可以在程序中轻松地使用 Redis。Redisson 在 java.util 中常用接口的基础上，为我们提供了一系列具有分布式特性的工具类（比如我们用的RRateLimiter，Bloom filter），从而让使用者能够将精力更集中地放在处理业务逻辑上。

Ø Redisson是一个高级的分布式协调Redis客户端，能帮助用户在分布式环境中轻松实现一些Java的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。

Ø Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；
Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。

10. Redis的过期策略怎么实现的？
Ø     redis设置过期时间：
    expire key time(以秒为单位)--这是最常用的方式，除了字符串自己独有设置过期时间的方法外，其他方法都需要依靠expire方法来设置时间，如果没有设置时间，那缓存就是永不过期
    setex(String key, int seconds, String value)--字符串独有的方式

Ø     三种过期策略：
    a.定时删除
        含义：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除
        优点：保证内存被尽快释放
        缺点：若过期key很多，删除这些key会占用很多的CPU时间，在单线程CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key定时器的创建耗时，若为每一个设置过期时间的key创建一个定时器（将会有大量的定时器产生），性能影响严重

    b.懒汉式删除
        含义：key过期的时候不删除，每次通过key获取值的时候去检查是否过期，若过期，则删除，返回null（用的时候再检查删除）。
        优点：删除操作只发生在通过key取值的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步（如果此时还不删除的话，我们就会获取到了已经过期的key了）
        缺点：若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）

    c.定期删除
        含义：每隔一段时间执行一次删除过期key操作
        优点：通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用
        缺点：在内存友好方面，不如"定时删除"（会造成一定的内存占用，但是没有懒汉式那么占用内存）
 在CPU时间友好方面，不如"懒汉式删除"（会定期的去进行比较和删除操作，cpu方面不如懒汉式，但是比定时好）
       
Ø Redis 采用的是定期删除+惰性删除策略。然后定期加惰性还不生效的话，在采用内存淘汰机制。

 懒汉式删除流程：在进行get或setnx等操作时，先检查key是否过期；
                                     若过期，删除key，然后执行相应操作；
                                     若没过期，直接执行相应操作；
定期删除流程：简单而言，对指定个数个库的每一个库随机删除小于等于指定个数个过期key。
Redis 默认会每秒进行十次过期扫描，过期扫描不会遍历过期字典中所有的 key，而是采用了一种简单的贪心策略：
• 从过期字典中随机 20 个 key；
• 删除这 20 个 key 中已经过期的 key；
• 如果过期的 key 比率超过 1/4，那就重复步骤 1；
同时，为了保证过期扫描不会出现循环过度，导致线程卡死现象，算法还增加了扫描时间的上限，默认不会超过 25ms。
如果某一时刻，有大量key同时过期，Redis 会持续扫描过期字典，造成客户端响应卡顿，因此设置过期时间时，就尽量避免这个问题，在设置过期时间时，可以给过期时间设置一个随机范围，避免同一时刻过期。

Ø 如何配置定期删除执行时间间隔
redis的定时任务默认是1s执行十次，如果要修改这个值，可以在redis.conf中修改hz的值。
redis.conf中，hz默认设为10，提高它的值将会占用更多的cpu，当然相应的redis将会更快的处理同时到期的许多key，以及更精确的去处理超时。 hz的取值范围是1~500，通常不建议超过100，只有在请求延时非常低的情况下可以将值提升到100。

Ø 从节点过期key是如何删除的呢？主节点在key到期时，会在AOF文件里增加一条del指令。AOF文件被同步到从节点以后，从节点根据AOF中的这个del指令来执行删除过期key的操作。
从节点的这个过期key的处理策略，会导致一个问题，主节点已经删除的key，在从节点还是存在的。因为AOF同步del指令是异步的。
还有一个关键点，《redis深度》历险那本书这样写的：从节点不会过期扫描，从节点对过期的处理是被动的。


11. aof/rdb和复制功能对过期键的处理
Ø rdb
生成rdb文件：生成时，程序会对键进行检查，过期键不放入rdb文件。
载入rdb文件：载入时，如果以主服务器模式运行，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会忽略；如果以从服务器模式运行，无论键过期与否，均会载入数据库中，过期键会通过与主服务器同步而删除。

Ø aof
当服务器以aof持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被删除，那么aof文件不会因为这个过期键而产生任何影响；当过期键被删除后，程序会向aof文件追加一条del命令来显式记录该键已被删除。
aof重写过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的aof文件中。

Ø 复制
当服务器运行在复制模式下时，从服务器的过期删除动作由主服务器控制：
主服务器在删除一个过期键后，会显式地向所有从服务器发送一个del命令，告知从服务器删除这个过期键;
从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键;
从服务器只有在接到主服务器发来的del命令后，才会删除过期键。

12. 单线程的redis，如何知道要运行定时任务？
Ø redis是单线程的，线程不但要处理定时任务，还要处理客户端请求，线程不能阻塞在定时任务或处理客户端请求上，那么，redis是如何知道何时该运行定时任务的呢？
Redis 的定时任务会记录在一个称为最小堆的数据结构中。这个堆中，最快要执行的任务排在堆的最上方。在每个循环周期，Redis 都会将最小堆里面已经到点的任务立即进行处理。处理完毕后，将最快要执行的任务还需要的时间记录下来，这个时间就是接下来处理客户端请求的最大时长，若达到了该时长，则暂时不处理客户端请求而去运行定时任务。

13. Redis的内存淘汰策略？
• noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。
• allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 Key。（推荐使用，目前项目在用这种）(最近最久使用算法)
• allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 Key。（应该也没人用吧，你不删最少使用 Key，去随机删）
• volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 Key。这种情况一般是把 Redis 既当缓存，又做持久化存储的时候才用。（不推荐）
• volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 Key。（依然不推荐）
• volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 Key 优先移除。（不推荐）

14. 修改配置不重启Redis会实时生效吗？
Ø 针对运行实例，有许多配置选项可以通过 CONFIG SET 命令进行修改，而无需执行任何形式的重启。 从 Redis 2.2 开始，可以从 AOF 切换到 RDB 的快照持久性或其他方式而不需要重启 Redis。检索 ‘CONFIG GET *’ 命令获取更多信息。
Ø 但偶尔重新启动是必须的，如为升级 Redis 程序到新的版本，或者当你需要修改某些目前 CONFIG 命令还不支持的配置参数的时候。

15. Redis能否实现乐观锁？
Ø 锁可以分为乐观锁和悲观锁
所谓悲观锁，就是一个线程在修改某一个数据的时候，悲观地认为肯定会有其他线程也进行修改，怎么办呢，干脆我直接独占，等我修改完了，其他线程再去抢占，所以，这种锁性能不是很好，不适合对并发性要求高的场景。
所谓乐观锁，就是一个线程在修改某一个数据的时候，乐观地认为不会有其他线程进行修改，直接修改，然后再提交的时候检查一下是否有人修改过原来的数据(通过version)，如果有人修改过，那我就放弃修改，返回失败，或者重试，所以，这种比较宽松的加锁机制，性能显然要好一些。

Ø Redis中可以通过Watch命令来实现乐观锁。Watch会监视指定的key，并会发觉这些键是否被改动过了。如果在一个事务中开始执行之前，其他的客户端对已经监视的key进行了修改，那么当前事务就丢弃它的修改。


16. Redis的性能瓶颈在哪？
因为redis是单线程，所以Redis的性能和CPU无关。其性能瓶颈一般在两个地方：
其一是机器内存大小，内存大小关系到Redis存储的数据量
其二是网络带宽。Redis客户端执行一条命令分为四个过程：发送命令、命令排队、命令执行、返回结果。
而其中发送命令+返回结果这一过程被称为Round Trip Time（RTT，往返时间），Redis的客户端和服务端可能部署在不同的机器上，如果两地间隔太远的话，RTT会耗时比较久。

17. Redis的主备同步流程？
Ø 初次全量同步，当一个redis服务器初次向主服务器发送salveof命令时，redis从服务器会进行一次全量同步，同步的步骤如下图所示：
• slave服务器向master发送psync命令（此时发送的是psync ? -1），告诉master我需要同步数据了。
• master接收到psync命令后会进行BGSAVE命令生成RDB文件快照。
• 生成完后，会将RDB文件发送给slave。
• slave接收到文件会载入RDB快照，并且将数据库状态变更为master在执行BGSAVE时的状态一致。
• master会发送保存在缓冲区里的所有写命令，告诉slave可以进行同步了
• slave执行这些写命令。

Ø 命令传播
slave已经同步过master了，那么如果后续master进行了写操作，比如说一个简单的set name redis，那么master执行过当前命令后，会将当前命令发送给slave执行一遍，达成数据一致性
Ø 重新复制
当slave断开重连之后会进行重新同步，重新同步分完全同步和部分同步。master需要根据以下三点判断是否进行部分同步：
• 服务器运行ID
每个redis服务器开启后会生成运行ID。
当进行初次同步时，master会将自己的ID告诉slave，slave会记录下来，当slave断线重连后，发现ID是这个master的就会尝试进行部分重同步。当ID与现在连接的master不一样时会进行完整重同步。

• 复制偏移量
复制偏移量包括master复制偏移量和slave复制偏移量，当初次同步过后两个数据库的复制偏移量相同，之后master执行一次写命令，那么master的偏移量+1，master将写命令给slave，slave执行一次，slave偏移量+1，这样版本就能一致。

• 复制积压缓冲区
复制积压缓冲区是由master维护的固定长度的先进先出的队列。当slave发送psync，会将自己的偏移量也发送给master，当slave的偏移量之后的数据在缓冲区还存在，就会返回+continue通知slave进行部分重同步。当slave的偏移量之后的数据不在缓冲区了，就会进行完整重同步。

总流程如下：
• 当slave断开重连后，会发送psync 命令给master。
• master首先会对服务器运行id进行判断，如果与自己相同就进行判断偏移量
• master会判断自己的偏移量与slave的偏移量是否一致。
• 如果不一致，master会去缓冲区中判断slave的偏移量之后的数据是否存在。
• 如果存在就会返回+continue回复，表示slave可以执行部分同步了。
• master发送断线后的写命令给slave
• slave执行写命令。

