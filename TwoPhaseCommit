对于本地事务处理或者是集中式的事务处理系统（单机系统），一般采用ACID（原子性Atomicity、一致性Consistency、隔离性Isolation、持久性Duralibility
）模型来保证数据的一致性。而对于分布式系统，则采用的是CAP理论

ACID里的一致性指的是：一个事务在执行之前和执行之后，数据库必须都处于一致性的状态。如：有些事务尚未完成就被迫中断，且这些已完成的事务对数据库所做的修改已经有一部分写入物理数据库，这时数据库就处于一种不正确的状态，或者说不一致的状态。

CAP理论里的一致性指的是：数据在多个副本之间是否能够保持一致的特性。在分布式系统中，如果能够做到针对一个数据项的更新操作执行完成后，所有的用户都可以读取到最新的值，那么这样的系统就可以被认为具有强一致性
CAP理论的可用性：对于用户的每一个操作，请求总是能够在有限的时间内返回结果。
CAP理论的分区容错性：分布式系统在遇到任何的网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。

BASE理论（基本可用Basically Available、软状态Soft state、最终一致性Eventually consistent）是基于CAP逐步演化而来的，不同于ACID的强一致性模型，其核心思想是通过牺牲强一致性来获得可用性，即使无法做到强一致性，但每个应用可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。

二阶段提交将一个事务的处理过程分为了投票和执行两个阶段，其核心是对每个事务都采用先尝试提交的处理方式，如果失败，利用在阶段一中记录的Undo信息来执行事务Rollback，因此也可以将二阶段提交看做一个强一致性算法。

第一阶段：
	Ø 事务询问
	协调者向所有的参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应
	Ø 执行事务
	各参与者节点执行事务操作，并将Undo和Redo信息记入事务日志
	Ø 各参与者向协调者反馈事务询问的响应
	如果参与者成功执行了事务操作，那么就反馈YES给协调者，表示事务可以执行；如果没有成功执行事务，则反馈No，表示事务不可以执行

第二阶段：
加入协调者从所有参与者得到的反馈都是YES，则执行事务提交：
	Ø 发送提交请求
	协调者向所有的参与者发送commit请求
	Ø 事务提交
	参与者收到commit请求后，会执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源
	Ø 反馈事务提交结果
	参与者在完成事务提交之后，向协调者发送Ack消息
	Ø 完成事务
	协调者接受到所有参与者反馈的Ack消息后，完成事务

假如有参与者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，则会中断事务：
	Ø 发送回滚请求
	协调者向所有的参与者发送Rollback请求
	Ø 事务提交
	参与者收到Rollback请求后，会利用其在阶段一中记录的Undo信息来执行事务回滚操作，并清理占用的事务资源
	Ø 反馈事务回滚结果
	参与者在完成事务回滚之后，向协调者发送Ack消息
	Ø 中断事务
	协调者接受到所有参与者反馈的Ack消息后，完成事务中断

二阶段提交协议的优点：原理简单，实现方便
二阶段提交协议的缺点：
	Ø 同步阻塞：各个参与者在等待其他参与者响应的过程中，无法进行其他任何操作
	Ø 单点问题：协调者出现问题，整个二阶段提交流程将无法运转
	Ø 脑裂：若阶段二有部分参与者没有收到Commit请求，则整个分布式系统会出现数据不一致的现象
	Ø 太过保守：没有较为完善的容错机制，任意一个节点的失败都会导致整个事务的失败
	
三阶段提交：是2PC（Two-Phase Commit）的改进版，将二阶段提交协议的“提交事务请求”过程一分为二，形成了由CanCommit（确认自身是否可以执行事务操作），PreCommit（执行事务操作）和doCommit（执行事务提交）三个阶段组成的事务处理协议

为什么三阶段提交可以解决二阶段提交的无限期等待问题呢？假设有协调者cor,参与者a,b,c。
对于二阶段提交，假如第一阶段a回了NO，b和c回了YES，当第二阶段cor给a发完abort后挂了，然后a执行完后也挂了，这时b和c不知道最后的提案是什么，事务的状态的也是不确定，即使重新选出协调者也会数据不一致。反之，如果a回了YES，b和c有一个回了No也是一样的道理
对于三阶段提交，canpreCommit阶段挂了无所谓，因为没有执行事务；假如协调者在收到第一阶段参与者所有的响应后，
