Paxos算法是一种基于消息传递且具有高度容错特性的一致性算法，是目前公认的解决分布式一致性问题最有效的算法之一。在常见的分布式系统中，总会发生诸如机器宕机或网络异常等情况。Paxos算法需要解决的问题就是如何在一个可能发生上述异常的分布式系统中，快速且正确地在集群内部对某个数据的值达成一致，并且保证不论发生以上任何异常，都不会破坏整个系统的一致性。

Paxos算法的目标就是要保证最终有一个提案会被选定，当提案被选定后，进程最终也能获取到被选定的提案。
在该一致性算法中，有三种参与角色，我们用Proposer、Acceptor和Learner来表示。在具体的实现中，一个进程可能充当不止一种角色，在这里我们并不关心进程如何映射到各种角色。

综合前面讲解的内容，我们来对Paxos算法的提案选定过程进行一个陈述。结合Proposer和AccePtor对提案的处理逻辑，就可以得到如下类似干两阶段提交的算法执行过程。
阶段一
1.Proposer选择一个提案编号M。，然后向Acceptor的某个超过半数的子集成员发送编号为Mn的Prepare请求。
2．如果一个Acceptor收到一个编号为Mn的Prepare请求，且编号Mn大于该Acceptor已经响应的所有Prepare请求的编号，那么它就会将它已经批准过的最大编号的提案作为响应反馈给Proposer，同时该Acceptor会承诺不会再批准任何编号小于Mn的提案。
举个例子来说，假定一个AccePtor己经响应过的所有PrePare请求对应的提案编号分别为I、2、…、5和7，那么该Acceptor在接收到一个编号为8的Prepare请求后，就会将编号为7的提案作为响应反馈给Proposer。

阶段二
如果Proposer收到来自半数以上的Acceptor对于其发出的编号为Mn的Prepare请求的响应，那么它就会发送一个针对［Mn，Vn］提案的Accept请求给Acceptor。注意Vn提案的值就是收到的响应中编号最大的提案的值，如果响应中不包含任何提案，那么它就是任意值。
2．如果Acceptor收到这个针对［Mn，Vn］提案的Accept请求，只要该Acceptor尚未对编号大于Mn的PrePare请求做出响应，它就可以通过这个提案。

paxos有多个proposerl，相当于有多个leader可以发起事务。主要包括：
提案的选定：保证只有一个提案可以被选定

Proposer生成提案：根据Acceptor反馈的已经批准的最大编号的提案，生成最终的提案（编号，value值），其中value值是Acceptor所有响应中编号最大的提案的value值。

Acceptor批准提案：如果Acceptor收到针对［Mn，Vn] 提案的Accept请求，只要该Acceptor尚未对编号大于Mn的PrePare请求做出响应，它就可以通过这个提案。

learner如何获取提案：learner是提案接受者，备份使用，对集群的一致性没有什么影响，像记录员，learner获取提案大体有三种方案：
1、一旦Acceptor批准了一个提案，就将该提案发送给所有的Learner，缺点是通信次数太多了，每个Acceptor都要与所有的Learner逐一通信
2、learner搞成主从架构，虽然通信次数减少了，但是有单点风险，主Learner可能会故障

3、对方案二进行改进，可以将主Learner的范围扩大，即Acccptor可以将批准的提案发送给一个特定的Learner集合，该集合中的每个Learner都可以在一个提案被选定后通知所有其他的Learner。集合中的Learner个数越多，可靠性就越好，但同时网络通信的复杂度越高。
