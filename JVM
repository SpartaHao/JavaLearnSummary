1. javac、java、javap 区别？
Ø javac将.java文件编译成.class文件；
Ø java命令运行一个.class文件，即执行字节码文件
Ø javap是 Java class文件分解器，可以反编译，也可以查看java编译器生成的字节码。用于分解class文件，变成便于理解的可读形式

2. JDK、JRE、JVM的关系？
JDK（Java Development Kit）简单理解就是Java开发工具包。JDK是整个JAVA的核心，包括了Java运行环境JRE（Java Runtime Envirnment）、一堆Java工具（javac/java/jdb等）和Java基础的类库（即Java API 包括rt.jar）。jmap、jstat、jstack等工具就是放到jdk的bin目录下的。

JRE(Java Runtime Enviroment)是Java的运行环境。JDK中包含JRE，在JDK的安装目录下有一个名为jre的目录，在里面有两个文件夹bin和lib，在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre。

JVM( java virtual machine)也就是常常听到Java虚拟机。它是整个java实现跨平台的最核心的部分（安装jdk的时候需要选择linux和windows版），所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行，class文件并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行，类似于C#中的CLR。
只有JVM还不能成class的执行，因为在解释class的时候JVM需要调用解释所需要的类库lib，而jre包含lib类库。JVM从软件层面屏蔽不同操作系统在底层硬件与指令上的区别，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行，实现跨平台的。所有的程序只要有java虚拟机的支持，那么就可以实现程序的执行，并且不同的操作系统上会有不同版本的jvm。我是这样理解的，jvm相当于一个容器，放到不同的操作系统中，因为编写的Java程序经过编译后生成的字节码可以被JVM识别，JVM为程序运行屏蔽了底层操作系统的差异。

JDK是面向开发者的，JRE是面向使用JAVA程序的用户。JDK包含JRE，而JRE包含JVM，总的来说JDK是用于java程序的开发,而jre则是只能运行class而没有编译的功能，Eclipse、IntelliJ IDEA等其他IDE有自己的编译器而不是用JDK bin目录中自带的(javac.exe)，所以在安装时只需选中jre路径就ok了
图片参考：https://blog.csdn.net/qq_33862644/article/details/81182344

3. jvm内存模型描述一下

JVM虚拟机分为三部分：类装载子系统、字节码执行引擎、运行时数据区（内存模型）。根据JVM规范，其中内存模型由堆、栈（线程）、本地方法栈、方法区（元空间，存放的是常量、静态变量和类信息）、程序计数器组成。而 JVM 的优化问题主要在线程共享的数据区中：堆、方法区。

Ø 本地方法栈（线程私有）
和虚拟机栈类似，主要为虚拟机使用到的Native方法服务。也会抛出StackOverflowError 和OutOfMemoryError。

Ø 程序计数器
程序计数器（Program Counter Register）是一块较小的内存空间，可以看作是当前线程所执行字节码的行号指示器，指向下一个将要执行的指令代码，由执行引擎来读取下一条指令。更确切的说，一个线程的执行，是通过字节码解释器(字节码执行引擎)改变当前线程的计数器的值，来获取下一条需要执行的字节码指令，从而确保线程的正确执行。每运行完一行代码，程序计数器的值都会被字节码执行引擎修改。
为了确保线程切换后（上下文切换）能恢复到正确的执行位置，每个线程都有一个独立的程序计数器，各个线程的计数器互不影响，独立存储。也就是说程序计数器是线程私有的内存。
如果线程执行 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是 Native 方法，计数器值为Undefined。
程序计数器不会发生内存溢出（OutOfMemoryError即OOM）问题。

Ø 方法区（Method Area），1.8之后叫元空间
方法区同 Java 堆一样是被所有线程共享的区间，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码。更具体的说，静态变量+常量+类信息（版本、方法、字段等）+运行时常量池 存在方法区中。常量池是方法区的一部分。

注：JDK1.8 使用元空间 MetaSpace 替代方法区，元空间并不在 JVM中，而是使用本地内存。元空间两个参数：
 MetaSpaceSize：初始化元空间大小，控制发生GC阈值
 MaxMetaspaceSize ： 限制元空间大小上限，防止异常占用过多物理内存


Ø 堆
堆时JVM内存占用最大，管理最复杂的一个区域。堆内存被所有线程共享。主要存放使用new关键字创建的对象。所有对象实例以及数组都要在堆上分配。垃圾收集器就是根据GC算法，收集堆上对象所占用的内存空间（收集的是对象占用的空间而不是对象本身）。jdk1.7以后，字符串常量从永久代中剥离出来，存放在堆中。

Java堆分为年轻代（Young Generation，1/3的堆空间）和老年代（Old Generation，2/3的堆空间）；年轻代又分为伊甸园（Eden, 8/10的年轻代空间）和幸存区（Survivor区, 2/10的年轻代空间）；幸存区又分为From Survivor空间和 To Survivor空间，分别占1/10。

年轻代存储“新生对象”，我们新创建的对象存储在年轻代中。当年轻内存占满后，会触发Minor GC，清理年轻代内存空间。

老年代存储长期存活的对象和大对象。年轻代中存储的对象，经过多次GC后仍然存活的对象会移动到老年代中进行存储。老年代空间占满后，会触发Full GC。 最有可能移到老年代的对象：静态对象、线程池、spring加载的bean对象，初始化时的一些缓存对象。
注：Full GC是清理整个堆空间，包括年轻代和老年代。如果Full GC之后，堆中仍然无法存储对象，就会抛出OutOfMemoryError异常。

Ø 栈
JVM 中的栈包括 Java 虚拟机栈和本地方法栈，两者的区别就是，Java 虚拟机栈为 JVM 执行 Java 方法服务，本地方法栈则为 JVM 使用到的 Native 方法服务。两者作用是极其相似的，本文主要介绍 Java 虚拟机栈，以下简称栈。

栈是线程私有的，他的生命周期与线程相同。每个线程都会分配一个栈的空间，即每个线程拥有独立的栈空间。

栈帧是栈的元素。每个方法在执行时都会创建一个栈帧。栈帧中存储了局部变量表、操作数栈、动态连接和方法出口等信息。每个方法从调用到运行结束的过程，就对应着一个栈帧在栈中压栈到出栈的过程。


v 局部变量表
栈帧中，由一个局部变量表存储数据。局部变量表中存储了基本数据类型（boolean、byte、char、short、int、float、long、double）的局部变量（包括参数）、和对象的引用（String、数组、对象等），但是不存储对象的内容。局部变量表所需的内存空间在编译期间完成分配，在方法运行期间不会改变局部变量表的大小。

局部变量的容量以变量槽（Variable Slot）为最小单位，每个变量槽最大存储32位的数据类型。对于64位的数据类型（long、double），JVM 会为其分配两个连续的变量槽来存储。以下简称 Slot 。
方法中定义的局部变量，其作用域不一定会覆盖整个方法。当方法运行时，如果已经超出了某个变量的作用域，即变量失效了，那这个变量对应的 Slot 就可以交给其他变量使用，也就是所谓的 Slot 复用。

JVM 通过索引定位的方式使用局部变量表，索引的范围从0开始至局部变量表中最大的 Slot 数量。普通方法与 static 方法在第 0 个槽位的存储有所不同。非 static 方法的第 0 个槽位存储方法所属对象实例的引用。

v 操作数栈
操作数栈是一个后进先出栈。操作数栈的元素可以是任意的Java数据类型。方法刚开始执行时，操作数栈是空的，在方法执行过程中，通过字节码指令对操作数栈进行压栈和出栈的操作。通常进行算数运算的时候是通过操作数栈来进行的（如a =1; b=2; c= a+b;会将1,2和结果3压入操作数栈），又或者是在调用其他方法的时候通过操作数栈进行参数传递。操作数栈可以理解为栈帧中用于计算的临时数据存储区。

v 动态连接
每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。Class文件的常量池中存在有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用，一部分会在类加载阶段或第一次使用的时候转化为直接引用（如final、static域等），称为静态解析，另一部分将在每一次的运行期间转化为直接引用（即：给出地址），这部分称为动态连接。多态就是其中的一种实现。

v 方法返回地址
记录方法执行完后，调用方法接下来要执行的位置。当一个方法被执行后，有两种方式退出该方法：执行引擎遇到了任意一个方法返回的字节码指令或遇到了异常，并且该异常没有在方法体内得到处理。无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行。方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的PC计数器的值就可以作为返回地址，栈帧中很可能保存了这个计数器值，而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，如果有返回值，则把它压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令。

Ø 栈中可能出现哪些异常？
StackOverflowError：栈溢出错误。
如果一个线程在计算时所需要用到栈大小 > 配置允许最大的栈大小，那么Java虚拟机将抛出 StackOverflowError

OutOfMemoryError：内存不足
 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。

如何设置栈参数？
使用 -Xss 设置栈大小，通常几百K就够用了。由于栈是线程私有的，线程数越多，占用栈空间越大。

栈决定了函数调用的深度。这也是慎用递归调用的原因。递归调用时，每次调用方法都会创建栈帧并压栈。当调用一定次数之后，所需栈的大小已经超过了虚拟机运行配置的最大栈参数，就会抛出 StackOverflowError 异常。

4. 常量池及其作用？
Ø 常量池中存储编译器生成的各种字面量和符号引用。字面量就是Java中常量的意思。比如文本字符串，final修饰的常量等。方法引用则包括类和接口的全限定名，方法名和描述符，字段名和描述符等。

Ø 作用：常量池避免了频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。

Ø Integer常量池：
public static void main(String[] args)
    {
        
        Integer i1 = new Integer(66);
        Integer i2 = new integer(66);
        Integer i3 = 66;
        Integer i4 = 66;
        Integer i5 = 150;
        Integer i6 = 150;
        System.out.println(i1 == i2);//false
        System.out.println(i3 == i4);//true
        System.out.println(i5 == i6);//false
    }
i3 == i4 为什么是 true 呢？Integer i3 = 66 实际上有一步装箱的操作，即将 int 型的 66 装箱成 Integer，通过 Integer 的 valueOf 方法。Integer 的 valueOf 方法很简单，它判断变量是否在 IntegerCache 的最小值（-128）和最大值（127）之间，如果在，则返回常量池中的内容，否则 new 一个 Integer 对象。

Ø String常量池：
String 是由 final 修饰的类，是不可以被继承的。通常有两种方式来创建对象。

String str = new String("abcd");
第一种使用 new 创建的对象，存放在堆中。每次调用都会创建一个新的对象。

String str = "abcd";
第二种先在栈上创建一个 String 类的对象引用变量 str，然后通过符号引用去字符串常量池中找有没有 “abcd”，如果没有，则将“abcd”存放到字符串常量池中，并将栈上的 str 变量引用指向常量池中的“abcd”。如果常量池中已经有“abcd”了，则不会再常量池中创建“abcd”，而是直接将 str 引用指向常量池中的“abcd”。

Ø 关于字符串 + 号连接问题：对于字符串常量的 + 号连接，在程序编译期，JVM就会将其优化为 + 号连接后的值。所以在编译期其字符串常量的值就确定了。
String a = "a3.4";   
String b = "a" + 3.4;   
System.out.println((a == b)); //result = true

关于字符串引用 + 号连接问题：对于字符串引用的 + 号连接问题，由于字符串引用在编译期是无法确定下来的，在程序的运行期动态分配并创建新的地址存储对象。
public static void main(String[] args){
       String str1 = "a";
	   String str2 = "ab";
	   String str3 = str1 + "b";
	   System.out.print(str2 == str3);//false
    }
对于上边代码，str3 等于 str1 引用 + 字符串常量“b”，在编译期无法确定，在运行期动态的分配并将连接后的新地址赋给 str3，所以 str2 和 str3 引用的内存地址不同，所以 str2 == str3 结果为 false。
注：我们已经知道了字符串引用的 + 号连接问题，其实是在运行期间创建一个 StringBuilder 对象，使用其 append 方法将字符串连接起来。这个也是我们开发中需要注意的一个问题，就是尽量不要在 for 循环中使用 + 号来操作字符串。

Ø final String str1 = "a";
        String str2 = "ab";
        String str3 = str1 + "b";
        System.out.print(str2 == str3);//true
final 修饰的变量是一个常量，编译期就能确定其值。所以 str1 + "b"就等同于 "a" + "b"，所以结果是 true。

Ø String s = "ab";
        String s1 = "a";
        String s2 = "b";
        String s3 = s1 + s2;
        System.out.println(s3 == s);//false
        System.out.println(s3.intern() == s);//true
s3 调用 intern 方法，返回的是s3的内容（ab）在常量池中的地址值。所以 s3.intern() == s 结果为 true。
原文链接： https://blog.csdn.net/rongtaoup/article/details/89142396
图片：
https://blog.csdn.net/qzqanzc/article/details/81008598
https://zhuanlan.zhihu.com/p/101495810

