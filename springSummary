spring是一个框架，在我们整个开发过程中，所有的框架生成都依赖spring。spring帮我们起到了一个IOC容器的作用，用来承载我们整体的bean对象。它帮我们进行了整个对象从创建到销毁的整个生命周期的管理。可以使用配置文件或注解的方式来进行相关实现。当我们程序开始启动之后，要把注解或者配置文件定义好的那些bean对象转换成一个BeanDefinition，然后完成整个BeanDefinition的解析和加载过程；当我们获取到这些完整对象之后，下一步要对整个BeanDefinition进行实例化操作，最简单的方式是通过反射的方式来创建对象。此时创建的对象只是在堆中开辟了空间，并没有完成后续的一系列初始化操作。当整个对象创建完成后，就可以进行调用了。

spring：是一个容器，用来存储bean对象。使用Map来存，因为我们一般是通过context.getBean（****.class）来获取对象，通过某个key当然用Map比较好

所有定义的bean对象最终都会被解析为BeanDifinition，bean定义对象。
通过BeanDifinition实例化对象时，是通过反射的方式，因为比较灵活。BeanDifinition里面都是占位符，通过PlaceholderConfigurerSupport（BeanFactoryPostProcessor的子类）将占位符替换为对应的数值。

PlaceholderConfigurerSupport： Abstract base class for property resource configurers that resolve placeholders in bean definition property values.

通过doProcessConfigurationClass完成标签或者注解的解析。该方法是ConfigurationClassPostProcessor来的。

	13. Spring怎么解决循环依赖问题的？
	Ø 什么是循环依赖？
	循环依赖-->循环引用。--->即2个或以上bean 互相持有对方，最终形成闭环。eg：A依赖B，B依赖C，C又依赖A。
	
	Ø spring的循环依赖的理论依据其实是基于Java的引用传递，当我们获取到对象的引用时，对象的field或zh属性是可以延后设置的(但是构造器必须是在获取引用之前)。
	
	Spring的单例对象的初始化主要分为三步：
	    ①：createBeanInstance：实例化，其实也就是 调用对象的构造方法实例化对象
	    ②：populateBean：填充属性，这一步主要是多bean的依赖属性进行填充
	    ③：initializeBean：调用spring xml中的init() 方法。
	从上面讲述的单例bean初始化步骤我们可以知道，循环依赖主要发生在第一、第二步。也就是构造器循环依赖和field循环依赖。
	那么我们要解决循环引用也应该从初始化过程着手，对于单例来说，在Spring容器整个生命周期内，有且只有一个对象，所以很容易想到这个对象应该存在Cache中，Spring为了解决单例的循环依赖问题，使用了三级缓存。
	
	Ø 这三级缓存分别指：
	 singletonFactories ： 单例对象工厂的cache ，三级缓存
	 earlySingletonObjects ：提前暴光的单例对象的Cache 。【用于检测循环引用，与singletonFactories互斥】
	 singletonObjects：单例对象的cache，一级缓存
	
	我们在创建bean的时候，首先想到的是从cache中获取这个单例的bean，这个缓存就是singletonObjects。分析getSingleton()的整个过程，Spring首先从一级缓存singletonObjects中获取。如果获取不到，并且对象正在创建中，就再从二级缓存earlySingletonObjects中获取。如果还是获取不到且允许singletonFactories通过getObject()获取，就从三级缓存singletonFactory.getObject()(三级缓存)获取，如果获取到了则
	从singletonFactories中移除，并放入earlySingletonObjects中。其实也就是从三级缓存移动到了二级缓存。Spring解决循环依赖的诀窍就在于singletonFactories这个三级cache。
	
	Ø 让我们来分析一下“A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象”这种循环依赖的情况。A首先完成了初始化的第一步，并且将自己提前曝光到singletonFactories中，此时进行初始化的第二步，发现自己依赖对象B，此时就尝试去get(B)，发现B还没有被create，所以走create流程，B在初始化第一步的时候发现自己依赖了对象A，于是尝试get(A)，尝试一级缓存singletonObjects(肯定没有，因为A还没初始化完全)，尝试二级缓存earlySingletonObjects（也没有），尝试三级缓存singletonFactories，由于A通过ObjectFactory将自己提前曝光了，所以B能够通过ObjectFactory.getObject拿到A对象(虽然A还没有初始化完全，但是总比没有好呀)，B拿到A对象后顺利完成了初始化阶段1、2、3，完全初始化之后将自己放入到一级缓存singletonObjects中。此时返回A中，A此时能拿到B的对象顺利完成自己的初始化阶段2、3，最终A也完成了初始化，进去了一级缓存singletonObjects中，而且更加幸运的是，由于B拿到了A的对象引用，所以B现在hold住的A对象完成了初始化。
	知道了这个原理时候，肯定就知道为啥Spring不能解决“A的构造方法中依赖了B的实例对象，同时B的构造方法中依赖了A的实例对象”这类问题了！因为加入singletonFactories三级缓存的前提是执行了构造器，所以构造器的循环依赖没法解决。

